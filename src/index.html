<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-touch-fullscreen" content="yes" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />

    <script src="./gradstop.js"></script>
    <style>
      html, body {
        height: 100%;
        overflow: hidden;
        font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
        padding: 0;
        margin: 0;
        background-color: black;
      }

      #page-wrapper {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      #score-panel {
        height: 150px;
        display: flex;
      }

      .player {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 26px;
        border-width: 4px;
        border-style: dotted;
        border-color: transparent;
      }
      .player.current-answerer {
        border-color: yellow;
      }
      .player.current-question-for-player {
        background-color: red !important;
      }

      #question-panel {
        min-height: 150px;
        font-size: 23px;
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
      }

      #answers-panel {
        flex: 1;
        display: flex;
        flex-wrap: wrap;
      }
      #answers-panel .answer {
        width: calc(100% / 4);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 1;
        font-size: 24px;
      }
      #answers-panel .answer:hover {
        cursor: pointer;
      }
      #answers-panel .answer.on-answer-animation {
        animation-name: onAnswerAnimation;
        animation-duration: 0.5s;
        animation-iteration-count: 2;
        animation-timing-function: linear;
      }
      @keyframes onAnswerAnimation {
        0% { transform: scale(1); }
        25% { transform: scale(1.3); }
        50% { transform: scale(1); }
        75% { transform: scale(0.7); }
        100% { transform: scale(1.0); }
      }

      #menu-wrapper {
        display: none;
        justify-content: center;
        align-items: center;
        position: absolute;
        top: 0;
        bottom: 0;
        right: 0;
        left: 0;
        background-color: grey;
        opacity: 0.9;
        font-size: 32px;
      }
      #menu-wrapper.shown {
        display: flex;
      }
      #menu-wrapper .content {
        width: 250px;
      }
      .title {
        font-size: 24px;
        margin-top: 20px;
      }
      #menu-wrapper input[type=text] {
        width: 100%;
      }

      #end-of-round-wrapper {
        display: none;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 5%;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: transparent;
      }
      #end-of-round-wrapper.shown {
        display: flex;
      }

      #end-of-round-panel {
        width: 100%;
        height: 100%;
        background-color: burlywood;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding-top: 40px;
      }
      #end-of-round-panel .answerers {
        text-align: center;
        margin: 20px 0;
      }
      #end-of-round-panel .answerer + .answerer {
        margin-top: 5px;
      }
      #end-of-round-panel .answer {
        margin-bottom: 10px;
        font-weight: bold;
      }
      #end-of-round-panel .next-question {
        display: none;
        background-color: chocolate;
        border-radius: 10px;
        padding: 10px 25px;
        font-size: 30px;
        margin-top: 20px;
        cursor: pointer;
      }
      #end-of-round-panel .next-question.shown {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="page-wrapper">
      <div id="score-panel"></div>
      <div id="question-panel">
        <div id="answerer"></div>
        <div id="question"></div>
      </div>
      <div id="answers-panel"></div>
    </div>
    <div id="menu-wrapper">
      <div class="content">
        <div>
          menu
        </div>
        <div class="title">
          Players
        </div>
        <div>
          <input id="player-names-input" type="text">
        </div>
        <div class="title">
          Potential answers
        </div>
        <div>
          <input id="potential-answers-input" type="text">
        </div>
        <div>
          <input id="reset-game-button" type="submit" value="Reset game">
        </div>
      </div>
    </div>
    <div id="end-of-round-wrapper">
      <div id="end-of-round-panel">
        <div class="question title">
          Hvem er den første til at springe i faldskærm?
        </div>
        <div class="answerers">
          <div>Mads svarede Frida (0 point)</div>
          <div>Tobias svarede Nanna (1 point)</div>
        </div>
        <div class="answer">
          Det rigtige svar var Nanna
        </div>
        <div class="question-for-player-score">
          Nanna får 1 point
        </div>
        <div class="next-question">
          Næste runde
        </div>
      </div>
    </div>
    <script>
      const $body = document.body
      const $scorePanel = document.querySelector('#score-panel')
      const $questionPanel = document.querySelector('#question-panel')
      const $answersPanel = document.querySelector('#answers-panel')
      const $answerer = document.querySelector('#answerer')
      const $question = document.querySelector('#question')
      const $menuWrapper = document.querySelector('#menu-wrapper')
      const $playerNamesInput = document.querySelector('#player-names-input')
      const $potentialAnswersInput = document.querySelector('#potential-answers-input')
      const $resetGameButton = document.querySelector('#reset-game-button')
      const $endOfRoundWrapper = document.querySelector('#end-of-round-wrapper')
      const $endOfRoundQuestion = document.querySelector('#end-of-round-wrapper .question')
      const $endOfRoundAnswer = document.querySelector('#end-of-round-wrapper .answer')
      const $endOfRoundNextQuestionButton = document.querySelector('#end-of-round-wrapper .next-question')
      const $endOfRoundAnswerers = document.querySelector('#end-of-round-wrapper .answerers')
      const $endOfRoundQuestionForPlayerScore = document.querySelector('#end-of-round-wrapper .question-for-player-score')
      const currentQuestionState = {}
      const players = []
      const answers = []
      const questions = [
        'Hvem er den første til at springe i faldskærm?',
        'Hvem er den første på dansegulvet?',
        'Hvem tuder først?',
        'Hvem skal tisse næste gange?'
      ]
      let isInputAllowed = true

      init()

      function init () {
        // Load stored or default players and answers
        const { players, answers } = loadFromStorage()
        addPlayers(players)
        addAnswers(answers)

        // To make phone experience better, make sure users can't scroll
        document.body.addEventListener('touchmove', e => {
          e.preventDefault()
        }, {
          passive: false,
          useCapture: false
        })
        window.addEventListener('resize', () => {
          $body.clientWidth = window.innerWidth
          $body.clientHeight = window.innerHeight
        })
        window.addEventListener('load', () => window.dispatchEvent(new Event('resize')))

        // Add setup handler
        $body.addEventListener('keydown', e => {
          const isToggleMenuButton = e.key.toLowerCase() === 'escape'
          const isMenuShown = $menuWrapper.classList.contains('shown')
          if (!isToggleMenuButton) return

          if (isMenuShown) {
            $menuWrapper.classList.remove('shown')
          } else {
            $menuWrapper.classList.add('shown')
          }
        })

        $resetGameButton.addEventListener('click', resetGame)

        // Reset state
        resetState()

        // Start with first question
        firstQuestion()
        render()

        // If settings menu is set, then start by opening menu
        const shouldOpenSettings = location.search.includes('settings')
        if (shouldOpenSettings) {
          $menuWrapper.classList.add('shown')
        }
      }

      function createNode (type, className) {
        const node = document.createElement(type)
        const classNames = Array.isArray(className) ? className : [className]
        classNames.forEach(className => node.classList.add(className))
        return node
      }

      function firstQuestion () {
        currentQuestionState.question = questions[0]
        currentQuestionState.questionForPlayer = players[0]
        currentQuestionState.missingAnswerers = [...players]
        currentQuestionState.answerer = players[0]
        currentQuestionState.questionForPlayerAnswered = []
        currentQuestionState.answerersAnswers = []
      }

      function nextQuestion () {
        const currentQuestionForPlayerIndex = players.findIndex(player => player === currentQuestionState.questionForPlayer)
        const nextQuestionForPlayer = players[(1 + currentQuestionForPlayerIndex) % players.length]
        const currentQuestionQuestionIndex = questions.findIndex(question => question === currentQuestionState.question)
        const nextQuestion = questions[(1 + currentQuestionQuestionIndex) % questions.length]
        currentQuestionState.question = nextQuestion
        currentQuestionState.questionForPlayer = nextQuestionForPlayer
        currentQuestionState.missingAnswerers = Array(players.length).fill(0).map((_, index) =>
          players[(1 + index + currentQuestionForPlayerIndex) % players.length])
        currentQuestionState.answerer = currentQuestionState.missingAnswerers[0]
        currentQuestionState.questionForPlayerAnswered = []
        currentQuestionState.answerersAnswers = []
      }

      function changeQuestionFor (player) {
        currentQuestionFor = player
      }

      function changeAnswerer (player) {
        if (currentAnswerer) currentAnswerer.node.classList.remove('current')
        player.node.classList.add('current-answerer')
        currentAnswerer = player
      }

      async function onAnswer (answer) {
        const isQuestionForAndAnswererTheSame = currentQuestionState.answerer === currentQuestionState.questionForPlayer
        if (isQuestionForAndAnswererTheSame) {
          currentQuestionState.questionForPlayerAnswered = answer
        } else {
          currentQuestionState.answerersAnswers.push({
            answer,
            player: currentQuestionState.answerer
          })
        }
        currentQuestionState.missingAnswerers = currentQuestionState.missingAnswerers.filter(a => a !== currentQuestionState.answerer)

        const isRoundDone = currentQuestionState.missingAnswerers.length === 0
        if (!isRoundDone) {
          currentQuestionState.answerer.node.classList.remove('current-answerer')
          currentQuestionState.answerer = currentQuestionState.missingAnswerers[0]
          currentQuestionState.answerer.node.classList.add('current-answerer')
          render()
          return
        }

        const correctAnsweres = currentQuestionState.answerersAnswers.filter(pa => pa.answer === currentQuestionState.questionForPlayerAnswered)

        // End of round animation
        $endOfRoundQuestion.innerText = currentQuestionState.question
        $endOfRoundAnswer.innerText = ''
        $endOfRoundAnswerers.innerHTML = ''
        $endOfRoundNextQuestionButton.classList.remove('shown')
        $endOfRoundQuestionForPlayerScore.innerHTML = ''
        $endOfRoundWrapper.classList.add('shown')
        await sleep(3000)

        for (const player of players) {
          const isQuestionForPlayer = player === currentQuestionState.questionForPlayer
          const playersAnswer = currentQuestionState.answerersAnswers.find(a => a.player === player)
          if (isQuestionForPlayer) continue
          const $div = createNode('div', 'answerer')
          $div.innerText = `${player.name} svarede ${playersAnswer.answer.answerText}`
          $endOfRoundAnswerers.appendChild($div)
          await sleep(2000)
        }

        $endOfRoundAnswer.innerText = `Det rigtige svar var ${currentQuestionState.questionForPlayerAnswered.answerText}`
        await sleep(2000)
        $endOfRoundQuestionForPlayerScore.innerText = `${currentQuestionState.questionForPlayer.name} får ${correctAnsweres.length} point${correctAnsweres.length === 1 ? '' : 's'}`
        await sleep(2000)
        $endOfRoundNextQuestionButton.classList.add('shown')

        $endOfRoundNextQuestionButton.addEventListener('click', function clickHandler () {
          $endOfRoundNextQuestionButton.removeEventListener('click', clickHandler)
          $endOfRoundWrapper.classList.remove('shown')
          currentQuestionState.questionForPlayer.points += correctAnsweres.length
          correctAnsweres.forEach(({ player }) => { player.points += 1 })
          nextQuestion()
          render()
        })
      }

      async function sleep (ms) {
        return new Promise(r => setTimeout(r, ms))
      }

      function addPlayers (names) {
        names.forEach((name, index) => {
          const player = {}
          const color = gradstop({
            stops: names.length,
            inputFormat: 'hex',
            colorArray: ['#f70845', '#fb91ac']
          })[index]

          const $player = createNode('div', 'player')
          $player.innerText = `${name}: 0`
          $player.style = `background-color: ${color}`

          player.name = name
          player.color = color
          player.points = 0
          player.node = $player

          players.push(player)
        })
      }

      function addAnswers (potentialAnswers) {
        potentialAnswers.forEach((answerText, index) => {
          const answer = {}
          const color = gradstop({
            stops: potentialAnswers.length,
            inputFormat: 'hex',
            colorArray: ['#418626', '#a2de8a']
          })[index]

          const $answer = createNode('div', 'answer')
          $answer.innerText = answerText
          $answer.style = `background-color: ${color}`
          $answer.addEventListener('click', async () => {
            if (!isInputAllowed) return
            isInputAllowed = false

            $answer.classList.add('on-answer-animation')
            await sleep(1000)
            $answer.classList.remove('on-answer-animation')
            isInputAllowed = true
            onAnswer(answer)
          })

          answer.answerText = answerText
          answer.color = color
          answer.node = $answer

          answers.push(answer)
        })
      }

      function resetGame () {
        const newPlayerNames = $playerNamesInput.value.split(',').map(n => n.trim())
        const newPotentialAnswers = $potentialAnswersInput.value.split(',').map(a => a.trim())
        players.splice(0, players.length)
        answers.splice(0, answers.length)
        addPlayers(newPlayerNames)
        addAnswers(newPotentialAnswers)
        saveToStorage({
          players: newPlayerNames,
          answers: newPotentialAnswers
        })

        resetState()
        firstQuestion()
        render()
      }

      function resetState () {
        while ($scorePanel.firstChild) $scorePanel.removeChild($scorePanel.lastChild)
        while ($answersPanel.firstChild) $answersPanel.removeChild($answersPanel.lastChild)

        // Add players and answers to dom
        players.forEach(player => $scorePanel.appendChild(player.node))
        answers.forEach(answer => $answersPanel.appendChild(answer.node))
      }

      function render () {
        const { answerer, questionForPlayer, question } = currentQuestionState
        const isQuestionForAndAnswererTheSame = answerer === questionForPlayer

        players.forEach(player => {
          player.node.classList.remove('current-answerer')
          player.node.classList.remove('current-question-for-player')
          player.node.innerText = `${player.name}: ${player.points}`
        })
        answerer.node.classList.add('current-answerer')
        questionForPlayer.node.classList.add('current-question-for-player')

        $answerer.innerText = isQuestionForAndAnswererTheSame
          ? `${answerer.name}: Hvad ville du svare, hvis du blev spurgt om:`
          : `${answerer.name}: Hvad ville ${questionForPlayer.name} svare, hvis spørgsmålet lød:`
        $question.innerText = `"${question}"`

        $playerNamesInput.value = players.map(p => p.name).join(', ')
        $potentialAnswersInput.value = answers.map(p => p.answerText).join(', ')
      }

      function saveToStorage ({ players, answers }) {
        window.localStorage.setItem('players', JSON.stringify(players))
        window.localStorage.setItem('answers', JSON.stringify(answers))
      }

      function loadFromStorage () {
        const playersFromStorage = window.localStorage.getItem('players')
        const answersFromStorage = window.localStorage.getItem('answers')
        const players = playersFromStorage
          ? JSON.parse(playersFromStorage)
          : ['Foo', 'Bar']
        const answers = answersFromStorage
          ? JSON.parse(answersFromStorage)
          : ['Foo', 'Bar', 'Baz', 'Man', 'What', 'A', 'Flush']

        return {
          players,
          answers
        }
      }
    </script>
  </body>
</html>
